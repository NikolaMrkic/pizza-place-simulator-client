function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  }
  return t;
};

import * as React from 'react';
import Cell from './Cell';
import { hasData } from './_utils';
export default (function (columns, curCell, setCurCell, form) {
  var dataIndexMap = [];

  var loopColumns = function loopColumns(lColumns) {
    var dataIndexMapItem = [];
    return lColumns.map(function (item) {
      if (item.children) {
        var children = item.children,
            resCol = __rest(item, ["children"]);

        return _extends({}, resCol, {
          children: loopColumns(children)
        });
      } else {
        var _render = item.render,
            dataIndex = item.dataIndex,
            _item$editable = item.editable,
            editable = _item$editable === void 0 ? true : _item$editable,
            rules = item.rules,
            isSelect = item.isSelect,
            _children = item.children,
            res = __rest(item, ["render", "dataIndex", "editable", "rules", "isSelect", "children"]);

        var resItem = _extends({
          dataIndex: dataIndex
        }, res, {
          render: function render(text, record, rowIndex) {
            // 注意 editable 字段来自dataSource（通常由后端控制），用于控制行是否可编辑
            var _record$editable = record.editable,
                rowEditbale = _record$editable === void 0 ? true : _record$editable;
            var initialValue = hasData(_render ? _render(text, record, rowIndex) : text);
            var canRowEditbale = typeof rowEditbale === 'boolean' ? rowEditbale : function foo() {
              var _rowEditbale$disabled = rowEditbale.disabled,
                  disabled = _rowEditbale$disabled === void 0 ? [] : _rowEditbale$disabled;
              return !disabled.includes(dataIndex);
            }();

            if (editable && canRowEditbale) {
              // magic code
              dataIndexMapItem.includes(dataIndex) ? dataIndexMapItem = [dataIndex] : dataIndexMapItem.push(dataIndex);
              dataIndexMap[rowIndex] = dataIndexMapItem;
              var cellprops = {
                form: form,
                key: "".concat(dataIndex, "-").concat(rowIndex),
                dataIndex: dataIndex,
                rowIndex: rowIndex,
                curCell: curCell,
                onSetCurCell: setCurCell,
                initialValue: initialValue,
                rules: rules,
                isSelect: isSelect
              };
              return React.createElement(Cell, cellprops);
            }

            return React.createElement("div", {
              className: "editable-cell-uneditable"
            }, initialValue);
          }
        });

        return resItem;
      }
    });
  };

  return {
    editColumns: loopColumns(columns),
    dataIndexMap: dataIndexMap
  };
});